# feed/ai_services.py

import re
from datetime import datetime, timedelta
from typing import List, Dict, Optional
import warnings
warnings.filterwarnings('ignore')


class AIWritingAssistant:
    """
    Assistant d'√©criture IA (version basique + avanc√©e int√©gr√©e)
    """
    
    def __init__(self):
        # Initialiser les mod√®les ML (optionnels)
        self.sentiment_analyzer = None
        self.classifier = None
        
        try:
            from transformers import pipeline
            print("ü§ñ Chargement des mod√®les IA...")
            
            # Sentiment Analysis
            self.sentiment_analyzer = pipeline(
                "sentiment-analysis",
                model="nlptown/bert-base-multilingual-uncased-sentiment",
                device=-1
            )
            print("‚úÖ Sentiment analyzer charg√©")
        except Exception as e:
            print(f"‚ö†Ô∏è Sentiment analyzer non disponible: {e}")
        
        try:
            from transformers import pipeline
            # Zero-shot Classification
            self.classifier = pipeline(
                "zero-shot-classification",
                model="facebook/bart-large-mnli",
                device=-1
            )
            print("‚úÖ Classifier charg√©")
        except Exception as e:
            print(f"‚ö†Ô∏è Classifier non disponible: {e}")
    
    def check_grammar(self, text: str) -> List[Dict]:
        """
        V√©rifications grammaticales basiques
        """
        suggestions = []
        
        # Doubles espaces
        if '  ' in text:
            suggestions.append({
                'type': 'grammar',
                'message': 'Espaces multiples d√©tect√©s',
                'replacements': [text.replace('  ', ' ')],
                'context': 'Utilisez un seul espace',
            })
        
        # Ponctuation manquante
        if len(text) > 20 and not text.rstrip().endswith(('.', '!', '?')):
            suggestions.append({
                'type': 'grammar',
                'message': 'Le texte ne se termine pas par une ponctuation',
                'replacements': [],
                'context': 'Ajoutez un point final',
            })
        
        # Majuscule au d√©but
        if text and not text[0].isupper() and not text[0].isdigit():
            suggestions.append({
                'type': 'grammar',
                'message': 'Le texte devrait commencer par une majuscule',
                'replacements': [text[0].upper() + text[1:]],
                'context': 'Premi√®re lettre en majuscule',
            })
        
        # Fautes courantes
        common_errors = {
            r'\bsa\b': '√ßa',
            r'\bmalgres\b': 'malgr√©',
            r'\bparmis\b': 'parmi',
            r'\bbiensur\b': 'bien s√ªr',
        }
        
        for pattern, correction in common_errors.items():
            if re.search(pattern, text, re.IGNORECASE):
                suggestions.append({
                    'type': 'grammar',
                    'message': f'Orthographe possible: "{correction}"',
                    'replacements': [correction],
                    'context': 'V√©rifiez l\'orthographe',
                })
        
        return suggestions[:5]
    
    def suggest_improvements(self, text: str, content_type: str) -> List[str]:
        """
        Suggestions d'am√©lioration selon le type de contenu
        """
        suggestions = []
        
        # V√©rifications g√©n√©rales
        if len(text) < 20:
            suggestions.append("üìù Message trop court. Ajoutez plus de d√©tails.")
        
        if len(text) > 1000:
            suggestions.append("‚úÇÔ∏è Message long. R√©sumez ou structurez en points.")
        
        sentences = text.count('.') + text.count('!') + text.count('?')
        if sentences == 0 and len(text) > 50:
            suggestions.append("üí¨ Ajoutez de la ponctuation pour structurer.")
        
        # Suggestions par type
        if content_type == 'programme':
            keywords = ['chapitre', 'cours', 'le√ßon', 's√©ance', 'module']
            if not any(word in text.lower() for word in keywords):
                suggestions.append("üìö Ajoutez des d√©tails sur le contenu (chapitres, le√ßons).")
            
            if not re.search(r'\d+', text):
                suggestions.append("üî¢ Ajoutez des r√©f√©rences num√©riques.")
        
        elif content_type == 'echeance':
            date_keywords = ['date', 'deadline', 'avant', 'jusqu\'au', 'limite']
            if not any(word in text.lower() for word in date_keywords):
                suggestions.append("üìÖ Pr√©cisez la date limite.")
            
            submission_keywords = ['rendu', 'soumission', 'd√©p√¥t', 'livrer']
            if not any(word in text.lower() for word in submission_keywords):
                suggestions.append("üì§ Indiquez le mode de soumission.")
        
        elif content_type == 'difficulte':
            if '?' not in text:
                suggestions.append("‚ùì Ajoutez une question pr√©cise.")
        
        elif content_type == 'ressource':
            link_keywords = ['http', 'www', 'lien', 'document', 'pdf']
            if not any(word in text.lower() for word in link_keywords):
                suggestions.append("üîó Ajoutez un lien vers la ressource.")
        
        # V√©rification du ton
        tone_suggestion = self._check_tone(text, content_type)
        if tone_suggestion:
            suggestions.append(tone_suggestion)
        
        return suggestions
    
    def _check_tone(self, text: str, content_type: str) -> str:
        """V√©rifie si le ton est appropri√©"""
        urgent_words = ['urgent', 'imm√©diat', 'vite', 'rapidement', 'asap']
        formal_words = ['veuillez', 'merci de', 'pri√®re de', 'cordialement']
        
        has_urgent = any(word in text.lower() for word in urgent_words)
        has_formal = any(word in text.lower() for word in formal_words)
        
        if content_type == 'programme' and has_urgent:
            return "‚ö†Ô∏è Ton urgent. Un programme devrait √™tre informatif."
        
        if content_type == 'echeance' and not has_urgent and not has_formal:
            return "üíº Ajoutez des formules de politesse."
        
        if content_type == 'annonce' and not has_formal:
            return "üì¢ Une annonce devrait avoir un ton formel."
        
        return ""
    
    def adapt_tone(self, text: str, content_type: str) -> str:
        """Adapte le ton selon le type"""
        if content_type == 'programme':
            if not text.startswith('üìö'):
                return "üìö " + text
        
        elif content_type == 'echeance':
            if not any(word in text.lower() for word in ['merci', 'cordialement']):
                return text + "\n\n‚è∞ Merci de respecter cette √©ch√©ance."
        
        elif content_type == 'annonce':
            if not text.startswith('üì¢'):
                return "üì¢ " + text
        
        return text
    
    # ========== FONCTIONNALIT√âS IA AVANC√âES ==========
    
    def analyze_sentiment(self, text: str) -> Dict:
        """
        Analyse le sentiment avec IA (positif/n√©gatif/neutre)
        """
        if not self.sentiment_analyzer or len(text) < 10:
            return {
                'sentiment': 'neutre',
                'emoji': 'üòê',
                'confidence': 0.0,
                'score': 3,
                'method': 'default'
            }
        
        try:
            result = self.sentiment_analyzer(text[:512])[0]
            stars = int(result['label'].split()[0])
            
            if stars >= 4:
                sentiment = 'positif'
                emoji = 'üòä'
            elif stars <= 2:
                sentiment = 'n√©gatif'
                emoji = 'üòû'
            else:
                sentiment = 'neutre'
                emoji = 'üòê'
            
            return {
                'sentiment': sentiment,
                'emoji': emoji,
                'confidence': round(result['score'], 2),
                'score': stars,
                'method': 'AI'
            }
        except Exception as e:
            return {
                'sentiment': 'neutre',
                'emoji': 'üòê',
                'confidence': 0.0,
                'score': 3,
                'method': 'error'
            }
    
    def detect_emotion(self, text: str) -> Dict:
        """
        D√©tecte l'√©motion avec zero-shot classification
        """
        if not self.classifier or len(text) < 10:
            return {
                'emotion': 'neutre',
                'emoji': 'üòê',
                'confidence': 0.0,
                'method': 'default'
            }
        
        try:
            emotions = ['joie', 'col√®re', 'tristesse', 'peur', 'surprise', 'neutre']
            result = self.classifier(text[:512], candidate_labels=emotions)
            
            emotion_emojis = {
                'joie': 'üòÑ', 'col√®re': 'üò†', 'tristesse': 'üò¢',
                'peur': 'üò∞', 'surprise': 'üò≤', 'neutre': 'üòê'
            }
            
            emotion = result['labels'][0]
            
            return {
                'emotion': emotion,
                'emoji': emotion_emojis.get(emotion, 'üòê'),
                'confidence': round(result['scores'][0], 2),
                'all_scores': dict(zip(result['labels'], result['scores'])),
                'method': 'AI'
            }
        except Exception as e:
            return {
                'emotion': 'neutre',
                'emoji': 'üòê',
                'confidence': 0.0,
                'method': 'error'
            }
    
    def predict_engagement(self, text: str, content_type: str) -> Dict:
        """
        Pr√©dit le niveau d'engagement potentiel
        """
        score = 0.5
        factors = {
            'length': 0, 'questions': 0, 'emojis': 0,
            'urgency': 0, 'readability': 0, 'sentiment': 0
        }
        
        # 1. Longueur optimale
        length = len(text)
        if 100 <= length <= 500:
            factors['length'] = 0.2
        elif 50 <= length < 100 or 500 < length <= 800:
            factors['length'] = 0.1
        
        # 2. Questions
        factors['questions'] = min(text.count('?') * 0.1, 0.2)
        
        # 3. Emojis
        emoji_pattern = re.compile(r'[\U0001F300-\U0001F9FF]|[\u2600-\u26FF]')
        emoji_count = len(emoji_pattern.findall(text))
        factors['emojis'] = min(emoji_count * 0.05, 0.15)
        
        # 4. Urgence
        urgent_words = ['urgent', 'important', 'attention', 'nouveau', 'exclusif']
        urgency_count = sum(1 for word in urgent_words if word in text.lower())
        factors['urgency'] = min(urgency_count * 0.08, 0.15)
        
        # 5. Lisibilit√©
        sentences = text.count('.') + text.count('!') + text.count('?')
        if sentences > 0:
            words = len(text.split())
            avg_sentence_length = words / sentences
            if avg_sentence_length < 20:
                factors['readability'] = 0.15
            elif avg_sentence_length < 30:
                factors['readability'] = 0.1
        
        # 6. Sentiment
        sentiment_result = self.analyze_sentiment(text)
        if sentiment_result['sentiment'] == 'positif':
            factors['sentiment'] = 0.15
        elif sentiment_result['sentiment'] == 'neutre':
            factors['sentiment'] = 0.05
        
        score += sum(factors.values())
        score = min(score, 1.0)
        
        if score >= 0.8:
            level, emoji, color = 'Tr√®s √©lev√©', 'üî•', 'success'
        elif score >= 0.6:
            level, emoji, color = '√âlev√©', 'üìà', 'info'
        elif score >= 0.4:
            level, emoji, color = 'Moyen', 'üìä', 'warning'
        else:
            level, emoji, color = 'Faible', 'üìâ', 'danger'
        
        suggestions = []
        if factors['length'] < 0.1:
            suggestions.append("‚úçÔ∏è Ajustez la longueur (100-500 caract√®res)")
        if factors['questions'] == 0:
            suggestions.append("‚ùì Ajoutez une question")
        if factors['emojis'] < 0.05:
            suggestions.append("üòä Utilisez des emojis")
        if factors['sentiment'] < 0.1:
            suggestions.append("üåü Ton plus positif")
        
        return {
            'score': round(score, 2),
            'percentage': round(score * 100),
            'level': level,
            'emoji': emoji,
            'color': color,
            'factors': {k: round(v, 2) for k, v in factors.items()},
            'suggestions': suggestions
        }
    
    def calculate_quality_score(self, text: str, content_type: str) -> float:
        """Score de qualit√© global (0-10)"""
        score = 5.0
        
        # Grammaire
        grammar_issues = self.check_grammar(text)
        if len(grammar_issues) == 0:
            score += 1.5
        elif len(grammar_issues) <= 2:
            score += 0.5
        
        # Longueur
        if 100 <= len(text) <= 1000:
            score += 1.0
        elif 50 <= len(text) < 100 or len(text) > 1000:
            score += 0.5
        
        # Structure
        punctuation = sum(text.count(p) for p in ['.', '!', '?', ','])
        if punctuation >= 3:
            score += 0.5
        
        # Sentiment
        sentiment = self.analyze_sentiment(text)
        if sentiment['sentiment'] == 'positif':
            score += 1.0
        elif sentiment['sentiment'] == 'neutre':
            score += 0.5
        
        # Pertinence
        type_keywords = {
            'programme': ['cours', 'chapitre', 'module', 'le√ßon'],
            'echeance': ['date', 'deadline', 'avant', 'rendu'],
            'difficulte': ['aide', 'question', 'probl√®me'],
            'ressource': ['lien', 'document', 'fichier'],
            'annonce': ['important', 'information', 'note']
        }
        
        keywords = type_keywords.get(content_type, [])
        matches = sum(1 for kw in keywords if kw in text.lower())
        score += min(matches * 0.3, 1.0)
        
        return min(round(score, 1), 10.0)
    
    def detect_spam_likelihood(self, text: str) -> Dict:
        """D√©tecte la probabilit√© de spam"""
        spam_indicators = 0
        reasons = []
        
        if text.isupper() and len(text) > 20:
            spam_indicators += 2
            reasons.append("Texte en MAJUSCULES")
        
        if text.count('!') > 5:
            spam_indicators += 1
            reasons.append(f"Trop de '!' ({text.count('!')})")
        
        spam_words = ['gratuit', 'cliquez ici', 'argent', 'gagnez']
        if sum(1 for word in spam_words if word in text.lower()) >= 2:
            spam_indicators += 2
            reasons.append("Mots suspects")
        
        if len(re.findall(r'http[s]?://', text)) > 3:
            spam_indicators += 1
            reasons.append("Trop de liens")
        
        if spam_indicators >= 4:
            likelihood, is_spam, color = 'Tr√®s √©lev√©', True, 'danger'
        elif spam_indicators >= 2:
            likelihood, is_spam, color = 'Moyen', False, 'warning'
        else:
            likelihood, is_spam, color = 'Faible', False, 'success'
        
        return {
            'is_spam': is_spam,
            'likelihood': likelihood,
            'score': spam_indicators,
            'color': color,
            'reasons': reasons
        }
    
    def suggest_title(self, description: str, content_type: str) -> List[str]:
        """Sugg√®re des titres accrocheurs"""
        suggestions = []
        
        type_prefixes = {
            'programme': ['üìö Programme', 'üìñ Nouveau cours'],
            'echeance': ['üìÖ √âch√©ance', '‚è∞ Date limite'],
            'difficulte': ['‚ùì Question', 'ü§î Aide'],
            'ressource': ['üìñ Ressource', 'üîó Document'],
            'annonce': ['üì¢ Annonce', 'üîî Important']
        }
        
        prefixes = type_prefixes.get(content_type, [''])
        first_sentence = description.split('.')[0][:50]
        
        if first_sentence:
            suggestions.append(f"{prefixes[0]}: {first_sentence}...")
        
        keywords = re.findall(r'\b[A-Z√Ä-√ø][a-z√†-√ø]+\b', description)
        if keywords:
            suggestions.append(f"{prefixes[0]}: {' '.join(keywords[:3])}")
        
        return suggestions[:3]
    
    def auto_correct_common_errors(self, text: str) -> Dict:
        """Correction automatique"""
        original = text
        corrections = []
        
        fixes = {
            r'\bsa\b': ('√ßa', 'Orthographe'),
            r'\bmalgres\b': ('malgr√©', 'Orthographe'),
            r'\bbiensur\b': ('bien s√ªr', 'Orthographe'),
        }
        
        corrected = text
        for pattern, (replacement, reason) in fixes.items():
            matches = list(re.finditer(pattern, corrected, re.IGNORECASE))
            if matches:
                corrected = re.sub(pattern, replacement, corrected, flags=re.IGNORECASE)
                corrections.append({
                    'original': matches[0].group(),
                    'correction': replacement,
                    'reason': reason
                })
        
        if '  ' in corrected:
            corrected = re.sub(r'\s+', ' ', corrected)
            corrections.append({
                'original': 'Espaces multiples',
                'correction': 'Espaces uniques',
                'reason': 'Formatage'
            })
        
        return {
            'original': original,
            'corrected': corrected,
            'has_changes': original != corrected,
            'corrections': corrections,
            'count': len(corrections)
        }


class AIContentEnricher:
    """Service d'enrichissement automatique"""
    
    def __init__(self):
        pass
    
    def extract_dates(self, text: str) -> List[Dict]:
        """Extrait les dates"""
        dates = []
        
        patterns = [
            (r'\b(\d{1,2})[/-](\d{1,2})[/-](\d{2,4})\b', 'numeric'),
            (r'\b(\d{1,2})\s+(janvier|f√©vrier|fevrier|mars|avril|mai|juin|juillet|ao√ªt|aout|septembre|octobre|novembre|d√©cembre|decembre)\s+(\d{4})\b', 'textual'),
        ]
        
        for pattern, pattern_type in patterns:
            matches = re.finditer(pattern, text, re.IGNORECASE)
            for match in matches:
                parsed = self._parse_date(match.group())
                dates.append({
                    'text': match.group(),
                    'position': match.start(),
                    'parsed_date': parsed,
                    'type': pattern_type
                })
        
        return dates
    
    def _parse_date(self, date_str: str) -> Optional[datetime]:
        """Parse une date"""
        months = {
            'janvier': 1, 'f√©vrier': 2, 'fevrier': 2, 'mars': 3, 'avril': 4,
            'mai': 5, 'juin': 6, 'juillet': 7, 'ao√ªt': 8, 'aout': 8,
            'septembre': 9, 'octobre': 10, 'novembre': 11, 'd√©cembre': 12, 'decembre': 12
        }
        
        try:
            numeric_match = re.match(r'(\d{1,2})[/-](\d{1,2})[/-](\d{2,4})', date_str)
            if numeric_match:
                day = int(numeric_match.group(1))
                month = int(numeric_match.group(2))
                year = int(numeric_match.group(3))
                if year < 100:
                    year += 2000
                if 1 <= month <= 12 and 1 <= day <= 31:
                    return datetime(year, month, day)
            
            for month_name, month_num in months.items():
                if month_name in date_str.lower():
                    numbers = re.findall(r'\d+', date_str)
                    if numbers:
                        day = int(numbers[0])
                        year = int(numbers[1]) if len(numbers) > 1 else datetime.now().year
                        if 1 <= day <= 31:
                            return datetime(year, month_num, day)
        except:
            pass
        
        return None
    
    def suggest_resources(self, text: str, content_type: str) -> List[str]:
        """Sugg√®re des ressources"""
        suggestions = {
            'difficulte': [
                "üí° Rechercher des tutoriels YouTube",
                "üìñ Consulter la documentation",
                "üë• Forums √©tudiants"
            ],
            'programme': [
                "üìö Pr√©parer des supports",
                "üìù Cr√©er des exercices",
                "üé• Vid√©os explicatives"
            ],
            'ressource': [
                "üîñ Sauvegarder en favoris",
                "üì§ Partager avec le groupe"
            ],
            'echeance': [
                "‚è∞ D√©finir un rappel",
                "üìÖ Ajouter au calendrier"
            ],
            'annonce': [
                "üìß Envoyer par email",
                "üìå √âpingler"
            ]
        }
        
        return suggestions.get(content_type, [])
    
    def extract_action_items(self, text: str) -> List[Dict]:
        """Extrait les actions √† faire"""
        action_items = []
        
        patterns = [
            r'(?:il faut|faut|devez|devons)\s+([^.!?]+)',
            r'(?:rendre|soumettre|livrer)\s+([^.!?]+)',
        ]
        
        for pattern in patterns:
            matches = re.finditer(pattern, text, re.IGNORECASE)
            for match in matches:
                action = match.group(1).strip()
                priority = 'high' if any(w in action.lower() for w in ['urgent', 'vite']) else 'normal'
                action_items.append({
                    'action': action,
                    'priority': priority,
                    'type': 'extracted'
                })
        
        return action_items
    
    def suggest_tags(self, text: str, content_type: str, max_tags: int = 5) -> List[str]:
        """Sugg√®re des tags"""
        default_tags = {
            'programme': ['cours', 'programme'],
            'echeance': ['deadline', '√©ch√©ance'],
            'difficulte': ['aide', 'question'],
            'ressource': ['ressource', 'document'],
            'annonce': ['annonce', 'info']
        }
        
        tags = set(default_tags.get(content_type, []))
        
        # Mots capitalis√©s
        capitalized = re.findall(r'\b[A-Z√Ä-≈∏][a-z√†-√ø]+\b', text)
        tags.update(word.lower() for word in capitalized[:3])
        
        return list(tags)[:max_tags]
    
    def detect_urgency_level(self, text: str, deadline: Optional[datetime]) -> Dict:
        """D√©tecte l'urgence"""
        urgency_score = 0
        reasons = []
        
        urgent_keywords = {
            'critique': 3, 'urgent': 3, 'imm√©diat': 3,
            'vite': 2, 'important': 1
        }
        
        for keyword, score in urgent_keywords.items():
            if keyword in text.lower():
                urgency_score += score
                reasons.append(f"Mot: '{keyword}'")
        
        if deadline:
            days_left = (deadline - datetime.utcnow()).days
            if days_left < 0:
                urgency_score += 5
                reasons.append("D√©pass√©e!")
            elif days_left <= 1:
                urgency_score += 3
                reasons.append(f"{days_left}j")
            elif days_left <= 3:
                urgency_score += 2
                reasons.append(f"{days_left}j")
        
        if urgency_score >= 5:
            level, emoji, color = 'Critique', 'üî¥', 'danger'
        elif urgency_score >= 3:
            level, emoji, color = '√âlev√©', 'üü†', 'warning'
        elif urgency_score >= 1:
            level, emoji, color = 'Moyen', 'üü°', 'info'
        else:
            level, emoji, color = 'Normal', 'üü¢', 'success'
        
        return {
            'level': level,
            'emoji': emoji,
            'color': color,
            'score': urgency_score,
            'reasons': reasons
        }


class AIRecurringContentGenerator:
    """G√©n√©ration de contenu r√©current"""
    
    @staticmethod
    def generate_deadline_reminder(feed_item) -> Optional[Dict]:
        """G√©n√®re un rappel d'√©ch√©ance"""
        if not feed_item.deadline:
            return None
        
        days_left = (feed_item.deadline - datetime.utcnow()).days
        
        if days_left <= 0:
            urgency = "‚è∞ URGENT - √âCH√âANCE D√âPASS√âE"
            message = f"L'√©ch√©ance '{feed_item.title}' est d√©pass√©e!"
        elif days_left == 1:
            urgency = "‚ö†Ô∏è DERNIER JOUR"
            message = f"Dernier jour pour '{feed_item.title}'!"
        elif days_left <= 3:
            urgency = "üìå RAPPEL"
            message = f"{days_left} jours pour '{feed_item.title}'."
        else:
            return None
        
        return {
            'title': f"{urgency} - {feed_item.title}",
            'description': f"{message}\n\n{feed_item.description}",
            'content_type': 'annonce',
            'deadline': feed_item.deadline,
            'is_ai_generated': True
        }
    
    @staticmethod
    def generate_weekly_summary(feed_items: List) -> Optional[Dict]:
        """G√©n√®re un r√©sum√© hebdo"""
        if not feed_items:
            return None
        
        total = len(feed_items)
        by_type = {}
        for item in feed_items:
            by_type[item.content_type] = by_type.get(item.content_type, 0) + 1
        
        summary = f"üìä **R√©sum√© hebdomadaire**\n\nTotal: {total}\n\n"
        
        emojis = {'programme': 'üìö', 'echeance': 'üìÖ', 'difficulte': 'ü§î', 'ressource': 'üìñ', 'annonce': 'üì¢'}
        
        for ctype, count in by_type.items():
            emoji = emojis.get(ctype, '‚Ä¢')
            summary += f"{emoji} {ctype.capitalize()}: {count}\n"
        
        upcoming = [i for i in feed_items if i.deadline and i.deadline > datetime.utcnow()]
        if upcoming:
            summary += f"\n‚è∞ **Prochaines √©ch√©ances:**\n"
            for item in sorted(upcoming, key=lambda x: x.deadline)[:5]:
                days = (item.deadline - datetime.utcnow()).days
                summary += f"‚Ä¢ {item.title} - {days}j\n"
        
        return {
            'title': f"üìä R√©sum√© - {datetime.now().strftime('%d/%m/%Y')}",
            'description': summary,
            'content_type': 'annonce',
            'is_ai_generated': True
        }
    
    @staticmethod
    def detect_missing_content(feed_items: List, days: int = 7) -> List[str]:
        """D√©tecte contenus manquants"""
        recent = datetime.utcnow() - timedelta(days=days)
        recent_items = [i for i in feed_items if i.created_at >= recent]
        
        existing = set(i.content_type for i in recent_items)
        all_types = {'programme', 'echeance', 'difficulte', 'ressource', 'annonce'}
        missing = all_types - existing
        
        messages = {
            'programme': "üìö Aucun programme publi√© cette semaine.",
            'echeance': "üìÖ Aucune √©ch√©ance d√©finie.",
            'ressource': "üìñ Aucune ressource partag√©e.",
            'difficulte': "ü§î Aucune question signal√©e.",
            'annonce': "üì¢ Aucune annonce publi√©e."
        }

        return [messages.get(ctype, f"Manque: {ctype}") for ctype in missing]